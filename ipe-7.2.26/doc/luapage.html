<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ipelib: Lua bindings for Document, Page, and StyleSheet</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ipelib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">The Ipe library documentation</a></li><li class="navelem"><a class="el" href="lua.html">Programming in Lua</a></li>  </ul>
</div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Lua bindings for Document, Page, and StyleSheet </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="luastyle"></a>
Stylesheet</h1>
<p>A stylesheet can be constructed by reading from a file (in XML format), or by creating an empty stylesheet: </p><pre class="fragment">-- create from file:
-- returns sheet or nil, error message
sheet = ipe.Sheet("filename")
-- create from XML data:
-- returns sheet or nil, error message
sheet = ipe.Sheet(nil, "&lt;ipestyle&gt; ... &lt;/ipestyle&gt;")
-- create empty stylesheet:
sheet = ipe.Sheet()    
</pre><p>Stylesheets have the following methods: </p><pre class="fragment">sheet:clone()            -- returns a private copy of the stylesheet
sheet:xml(with_bitmaps)  -- return XML representation 
sheet:add(kind, symbolic, value)
sheet:addFrom(other_sheet, kind, symbolic)
sheet:remove(kind, symbolic)                       
sheet:set(kind, value)
sheet:isStandard()      -- is this the built-in stylesheet?
sheet:name()            -- name of the stylesheet
sheet:setName(name)
</pre><p><code>sheet:add</code> adds a definition for symbolic name to the stylesheet. Permissible values for <code>kind</code> are: </p><pre class="fragment"> pen, symbolsize, arrowsize, color, dashstyle, textsize, textstretch, 
 textstyle, gridsize, anglesize, opacity, symbol, 
</pre><p><code>sheet:addFrom</code> copies a definition for a gradient, tiling, or effect from another stylesheet. This makes it possible to create such definitions by creating a temporary stylesheet from an XML string.</p>
<p><code>sheet:remove</code> removes the definition of a symbolic name from the stylesheet. This also works for symbols, gradients, tilings, and effects. It is permissible to remove a symbolic name that is not defined in the stylesheet.</p>
<p><code>sheet:set</code> sets a value. Permissible values for <code>kind</code> are: </p><pre class="fragment"> preamble, linecap, linejoin, fillrule
</pre><h1><a class="anchor" id="luacascade"></a>
Stylesheet cascade</h1>
<p>Documents own an entire stack of style sheets, the style sheet <em>cascade</em>. An empty style sheet cascade can be created like this: </p><pre class="fragment">sheets = ipe.Sheets()
</pre><p> or you can obtain one from an Ipe document.</p>
<p>Style sheet cascades have the following methods: </p><pre class="fragment">sheets1 = sheets:clone()              -- make a private copy
sheets:allNames(kind)
sheets:find(kind, symbolic)
sheets:has(kind, symbolic)
sheets:count()                        -- return number of sheets
sheets:sheet(index)                   -- return sheet at index
sheets:insert(index, style_sheet)     -- insert sheet at index
sheets:remove(index)                  -- delete a sheet
log = sheets:update(directory)        -- update style sheets from directory
</pre><p><code>sheets:allNames</code> returns a table with all symbolic names defined in the entire stylesheet cascade. Permissible values for <code>kind</code> are: </p><pre class="fragment"> pen, symbolsize, arrowsize, color, dashstyle, textsize, textstretch, 
 textstyle, gridsize, anglesize, opacity, tiling, symbol, gradient, effect
</pre><p><code>sheet:has</code> checks whether a symbolic name is defined in the cascade. Permissible values for <code>kind</code> are as for <code>allNames</code>.</p>
<p><code>sheet:find</code> looks up a symbolic definition. Permissible values for <code>kind</code> are: </p><pre class="fragment"> pen, symbolsize, arrowsize, color, dashstyle, textsize, textstretch, 
 textstyle, gridsize, anglesize, opacity, symbol, 
 preamble, linecap, linejoin, fillrule, layout
</pre><h1><a class="anchor" id="luapage1"></a>
Page</h1>
<p>Page objects can be created like this: </p><pre class="fragment">p = ipe.Page()   -- create basic page with one layer and one view
p1 = p:clone()   -- returns a copy of the page
</pre><p>The following methods act on the <b>views</b> of a page. Note that views are indexed starting from 1, as usual in Lua. </p><pre class="fragment">p:countViews() 
p:effect(view)
p:setEffect(view, effect)
p:active(view)
p:setActive(view, layer)
p:insertView(view, layer)
p:removeView(view)
p:clearViews()
f = p:viewMarked(view) -- return true/false
p:setViewMarked(view, f)
name = p:viewName(view)
p:setViewName(view, name)
map = p:viewMap(view)
p:setViewMap(view, map)
lm = p:layerMatrices(view)
p:setLayerMatrices(view, lm)
</pre><p>The following methods act on the <b>layers</b> of a page. Note that layers are always accessed by name, not by index as in C++. </p><pre class="fragment">p:countLayers()
p:layers()        -- return table of layer names
p:isLocked(layer)
p:setLocked(layer, boolean)
p:layerData(layer)    -- free-use text for that layer
p:setLayerData(layer, data)
p:hasSnapping(layer)
p:setSnapping(layer)
p:renameLayer(oldname, newname)
-- if layer is nil, automatically create name for new layer:
p:addLayer(layer)     -- add layer at the end, return name of new layer
p:removeLayer(layer)
p:moveLayer(layer, target_index)
p:visible(view, layer)   -- is layer visible in view?
p:setVisible(view, layer, boolean)
</pre><p>The <b>objects</b> of a page can be accessed by indexing, using an iterator, or with various methods. Note that object indices start with 1, as usual in Lua. </p><pre class="fragment">-- objects:

#p      -- return number of objects on page
p[i]    -- return object #i, where 1 &lt;= i &lt;= #p

-- iterate over objects of page:
for i, obj, sel, layer in p:objects() do
  print(i, obj, sel, layer)
end

p:select(objno)              -- returns nil, 1, or 2
p:setSelect(objno, status)   -- status is nil, 1, or 2
p:layerOf(objno)
p:setLayerOf(objno, layer)
p:visible(view, objno)       -- is object visible in view?
p:bbox(objno)                -- cached by page
p:invalidateBBox(objno)      -- invalidate cached bbox
p:insert(objno, object, select, layer)  -- objno == nil means append
p:remove(objno)
p:replace(objno, object)     -- automatically clones object
p:transform(objno, matrix)

-- returns true if attribute was actually changed
p:setAttribute(objno, property, value)
</pre><p>Finally, there are various methods to query and modify the currently selected objects, the page title and sections, etc.: </p><pre class="fragment">-- selection:
obj = p:primarySelection() -- nil if no primary selection
p:hasSelection()           -- true or false
p:deselectAll()
p:ensurePrimarySelection()

-- t is a table with fields "title", "section", "subsection"
-- if section or subsection is not a string, the title is used 
t = p:titles()  
p:setTitles(t)

-- n is a string
n = p:notes()
p:setNotes(n)

-- f is true/false
f = p:marked()
p:setMarked(f)
</pre><h1><a class="anchor" id="luadoc"></a>
Document</h1>
<p>Documents have the following methods: </p><pre class="fragment">doc = ipe.Document()         -- empty document
doc = ipe.Document(filename) -- load from file 
-- returns either document or nil, error message, error code

#doc    -- number of pages
doc[i]  -- return page #i, where 1 &lt;= i &lt;= #doc

-- format == nil: guess from filename
-- flags is either nil, or a table with keys
-- "export", "nozip", "lastview", "nocolor"
doc:save(filename, format, flags)  
doc:exportPages(filename, flags, fromPage, toPage)
doc:exportView(filename, format, flags, pageNo, viewNo)

-- iterating over pages of document:
for i, p in doc:pages() do
  print("Page number",  i, p)
end

doc:set(no, page)         -- replace with a clone of page, returns old page
doc:insert(no, page)
doc:append(page)
doc:remove(no)            -- returns page and removes from document
doc:countTotalViews()
doc:sheets()              -- returns style sheet cascade
old = doc:replaceSheets(sheets)  -- replace and return old cascade
doc:has(what)  -- where what in { "truetype", "gradients", "tilings", "transparency" }
doc:runLatex(docname)     -- pass filename of Ipe document or nil
-- returns either true, nil, result code, logfile
--         or     false, error message, result code, logfile

doc:fontPool()    -- returns light userdata
doc:checkStyle()  -- returns list of undefined symbolic names
t = doc:properties()  -- returns table
doc:setProperties(t)  -- changes properties set in table
</pre><p><code>doc:properties()</code> returns a table with the following fields (all fields exist even if their contents is an empty string): </p><pre class="fragment">title author subject keywords preamble created modified creator
fullscreen cropbox numberpages tex
</pre><h1><a class="anchor" id="luaother"></a>
Other functions</h1>
<pre class="fragment">ipe.fileFormat(filename)      -- returns one of "xml", "pdf", "eps", "ipe5", "unknown"
ipe.fileExists(filename)      -- returns true or false
ipe.realPath(filename)        -- convert relative path to absolute path
ipe.directory(path)           -- return list of files in directory
ipe.openFile(path, mode)      -- replacement for io.open
beziers = ipe.splineToBeziers(spline, is_closed, old_style)
ipelet = ipe.Ipelet(dllname)  -- loads C++ ipelet from absolute path
-- returns ipelet or nil, error message
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
<hr>
</body></html>
